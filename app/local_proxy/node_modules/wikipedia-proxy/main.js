/**
 * 用于绕过 SNI RST 的Node.js本地反代服务器
 * @author Xmader
 * @copyright Copyright (c) 2018 Xmader
 * @license MIT
 * @see https://github.com/Xmader/wikipedia-proxy#readme 查看文档
 */

const httpProxy = require("http-proxy")
const requires_port = require("requires-port")
const fs = require("fs")
const url = require("url")
const http = require("http")
const https = require("https")
const net = require("net") // eslint-disable-line no-unused-vars

const ips = require("./ip-addresses")
const dnsPromise = require("./dns")
const socks5 = require("./socks5.js")

/**
* @typedef {{src: string; dst: string; regex?: boolean;}[]} hostsConfig 
*/

const ssl = {
    cert: fs.readFileSync(`${__dirname}/cert.crt`),
    key: fs.readFileSync(`${__dirname}/rsa.key`)
}

const proxy = httpProxy.createProxyServer({})

proxy.on("proxyReq", async (proxyReq, req) => {
    proxyReq.setHeader("Host", req.headers.host)
})

proxy.on("error", function (e) {
    console.error(e)
})

const lookupHost = function (src, hosts) {
    const a = hosts.reverse().find(
        x => (x.regex && src.match(x.src)) || (src == x.src)
    )
    return a && a.dst
}

/**
 * @param {http.IncomingMessage} req 
 * @param {http.ServerResponse} res 
 * @param {hostsConfig} hostsConfig 
 */
const serverRequestListener = async (req, res, hostsConfig = []) => {
    const protocol = url.parse(req.url).protocol || "https:"
    const [hostname, port] = (req.headers.host).split(":")

    const ip = lookupHost(hostname, hostsConfig) || (await dnsPromise.resolve4(hostname))[0]
    const target = port ? `${protocol}//${ip}:${port}/` : `${protocol}//${ip}/`

    proxy.web(req, res, {
        target,
        changeOrigin: true,
        hostRewrite: `${hostname}`,
        secure: false
    })
}

/**
 * 运行反代服务器
 * @param {{port?: number; host?: string; protocol?: "https" | "http" | "socks5" ; silent?: boolean; hostsConfig: hostsConfig; }} options
 * @returns {net.Server}
 */
module.exports.run = function (options) {
    const { host, protocol, silent, hostsConfig } = { host: "0.0.0.0", protocol: "https", silent: false, hostsConfig: [], ...options }
    const port = (options.port | 0) || (protocol == "https" ? 443 : 80)

    const listener = (req, res) => serverRequestListener(req, res, hostsConfig)
    let server
    switch (protocol) {
        case "https":
            server = https.createServer(ssl, listener)
            break

        case "http":
            server = http.createServer(listener)
            break

        case "socks5":
            server = socks5.createServer(ssl, listener)
            break

        default:
            throw new Error("The protocol must be either 'https', 'http' or 'socks5'")
    }

    if (!silent) {
        const _port = requires_port(port, protocol) ? `:${port}` : ""
        const urls = host == "0.0.0.0"
            ? ["", ...ips].map(_host => _host && `${protocol}://${_host}${_port}`).join("\n  ")
            : `${protocol}://${host}${_port}`

        console.log(`listening on port ${port}`)
        console.log(`Available on: ${urls}`)
        console.log("Hit CTRL-C to stop the server")
    }

    server.listen(port, host)

    return server
}
