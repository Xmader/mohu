/**
 * 用于绕过 SNI RST 的Node.js本地反代服务器
 * @author Xmader
 * @copyright Copyright (c) 2018 Xmader
 * @license MIT
 * @see https://github.com/Xmader/wikipedia-proxy#readme 查看文档
 */

const httpProxy = require("http-proxy")
const requires_port = require("requires-port")
const fs = require("fs")
const url = require("url")
const http = require("http")
const https = require("https")
const { isIP } = require("net")

const ips = require("./ip-addresses")
const dnsPromise = require("./dns")
const socks5 = require("./socks5.js")

/**
* @typedef {{src: string; dst: string; regex?: boolean;}[]} hostsConfig 
*/

const ssl = {
    cert: fs.readFileSync(`${__dirname}/cert.crt`),
    key: fs.readFileSync(`${__dirname}/rsa.key`)
}

const DNSCache = new Map()

const proxy = httpProxy.createProxyServer({})

proxy.on("proxyReq", async (proxyReq, req) => {
    proxyReq.setHeader("Host", req.headers.host)
})

proxy.on("error", function (e, req, res, target) {
    if (e.message.startsWith("write EPROTO")) {
        const { hostname } = target
        const ip = DNSCache.get(hostname)

        target.hostname = ip

        const agent = new https.Agent()
        agent.options.servername = hostname

        proxy.web(req, res, {
            target,
            agent,
        })

    } else {
        console.error(e)
    }
})

const lookupHost = function (src, hosts) {
    const a = hosts.reverse().find(
        x => (x.regex && src.match(x.src)) || (src == x.src)
    )
    return a && a.dst
}

/**
 * @param {http.IncomingMessage} req 
 * @param {http.ServerResponse} res 
 * @param {hostsConfig} hostsConfig 
 */
const serverRequestListener = async (req, res, hostsConfig = []) => {
    const protocol = url.parse(req.url).protocol || "https:"
    const [hostname, port] = (req.headers.host).split(":")

    let ip = DNSCache.get(hostname)
    if (!ip) {
        ip = lookupHost(hostname, hostsConfig) || (await dnsPromise.resolve4(hostname))[0]
        DNSCache.set(hostname, ip)
    }

    if (!isIP(ip)) {  // hosts记录指向一个域名
        const href = url.parse(req.url)
        href.hostname = ip
        href.protocol = protocol

        res.writeHead(301, { location: url.format(href) })
        res.end()
        return
    }

    const target = port ? `${protocol}//${hostname}:${port}/` : `${protocol}//${hostname}/`

    // 应用自定义DNS解析
    const agent = new https.Agent()
    agent.options.servername = ip
    agent.options.lookup = (lookupHostname, opt, callback) => {
        callback(null, ip, 4)
    }
    
    proxy.web(req, res, {
        target,
        changeOrigin: true,
        hostRewrite: `${hostname}`,
        agent: agent,
        secure: false
    })
}

/**
 * 运行反代服务器
 * @param {{port?: number; host?: string; protocol?: "https" | "http" | "socks5" ; silent?: boolean; hostsConfig?: hostsConfig; }} options
 * @returns {import("net").Server}
 */
module.exports.run = function (options) {
    const { host, protocol, silent, hostsConfig } = { host: "0.0.0.0", protocol: "https", silent: false, hostsConfig: [], ...options }
    const port = (options.port | 0) || (protocol == "https" ? 443 : 80)

    const listener = (req, res) => serverRequestListener(req, res, hostsConfig)
    let server
    switch (protocol) {
        case "https":
            server = https.createServer(ssl, listener)
            break

        case "http":
            server = http.createServer(listener)
            break

        case "socks5":
            server = socks5.createServer(ssl, listener)
            break

        default:
            throw new Error("The protocol must be either 'https', 'http' or 'socks5'")
    }

    if (!silent) {
        const _port = requires_port(port, protocol) ? `:${port}` : ""
        const urls = host == "0.0.0.0"
            ? ["", ...ips].map(_host => _host && `${protocol}://${_host}${_port}`).join("\n  ")
            : `${protocol}://${host}${_port}`

        console.log(`listening on port ${port}`)
        console.log(`Available on: ${urls}`)
        console.log("Hit CTRL-C to stop the server")
    }

    server.listen(port, host)

    return server
}
